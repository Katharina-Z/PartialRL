using JuMP
using Ipopt


module CleanData
include("CleanData")
using .CleanData
export data, RewSum, TauSum, Reinf
end


function optimise(; verbose = true)
    RespTau = CleanData.data.RespLat
    RewSum = CleanData.data.RewSum
    Reinf = CleanData.data.Reinf[1]
    TauSum = CleanData.data.TauSum
    AvRew = 0.05
    num_trials = length(RespTau)

    m = Model(with_optimizer(Ipopt.Optimizer))

    @variable(m, 0.1 <= Ur[1:num_trials]<= 3)
    @variable(m, 0.01 <= Cu[1:num_trials] <= 1)
    @variable(m, 0.01 <= Cv[1:num_trials] <= 1)
    @variable(m, FutRew[1:num_trials]) #need to figure out what this is
    avrew = (RewSum - Cu) / TauSum

    @NLexpression(m, my_expr[i = 1:num_trials], (RewSum[i] - Cu[i]) / TauSum[i])

    @NLconstraint(m, 0 <= sum((Reinf*Ur[i]) - Cu[i] - (Cv[i]/RespTau[i]) - (AvRew*RespTau[i]) + FutRew[i] for i in 1:num_trials) <= 0.99)
    @NLobjective(m, Max, sum((Reinf*Ur[i]) - Cu[i] - (Cv[i]/RespTau[i]) - (AvRew*RespTau[i]) + FutRew[i] for i in 1:num_trials))

    JuMP.optimize!(m)

    if verbose
    println("RESULTS:")
        for i in 1:num_trials
            println("Objective value: ", JuMP.objective_value(m))
            println("Ur = ", JuMP.value(Ur))
            println("Cu = ", JuMP.value(Cu))
            println("Cv = ", JuMP.value(Cv))
            println("FutRew = ", JuMP.value(FutRew))
        end
    end
end

optimise(verbose=true)
